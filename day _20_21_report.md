# Project  1
Building this Node.js application was a very good experience for me. I made a backend service using Express, Mongoose, and MongoDB. The application handle CRUD operations to manage products and campaigns. This project teached me many things about using databases, handling HTTP requests, and working with Mongoose to interact with MongoDB.  

First, I setup the application by importing Express and Mongoose. Express is a framework for Node.js that make it easier to handle HTTP requests, routes, and middleware. Mongoose is a Object Data Modeling (ODM) library for MongoDB and Node.js. It provide a way to define schemas, validate data, and create models for MongoDB collections. This make working with MongoDB easier by providing helpful methods. In the code, I also setup Express app and use express.json() middleware. This middleware parse incoming JSON data so it can be accessed in the request body.  

After setting up Express and Mongoose, I connect to MongoDB using `mongoose.connect`. I passed the database URI `"mongodb://localhost:27017/test"` to connect to local MongoDB. The `.then` and `.catch` methods is used for handling success and error. When the connection is success, it logs "Database connected" to the console. If connection fail, the error is logged instead. This part of the code made me learn how to use promises in JavaScript. Promises help handling asynchronous operations, and using `.then` and `.catch` is a good way to handle success and errors.  

Creating Mongoose schemas and models was one of the interesting part of this project. Mongoose schemas are blueprints that defines how documents should look in MongoDB. I made two schemas: `campaignSchema` and `productSchema`. These schemas define what fields should be stored, their data types, and validation rules.  

The `campaignSchema` has fields like `id`, `productId`, `name`, `description`, `amount`, `percentage`, `createdAt`, and `updatedAt`. Each field has a data type like String, Number, or Date. Some fields are marked as required to make sure important data is not missing. The `productSchema` is more detailed with fields like `id`, `name`, `description`, `price`, `category`, `url`, `stock`, `size`, `composition`, `color`, `weight`, `images`, `campaign_Id`, and `deleted`.  

For the `category` field in productSchema, I used enum to limit values to "Electronics", "Clothing", and "Food". Using enums ensure only valid values can be stored in the database. The `deleted` field is set to false by default to mark products as active. This approach can be useful in soft delete situations where product is not actually removed from database but marked as deleted. I created models from the schemas using `mongoose.model`. Models provide methods like save, find, findOne, update, delete, and others to interact with MongoDB easily. This part was useful in understanding how schemas and models work together in Mongoose.  

The app has routes for managing products and campaigns. The `/products` POST route is used for creating new products and campaigns. In this route, I generated random numbers for `productId` and `campaign_Id` to create unique identifiers. But this approach can cause problems if same ID generated twice. A better idea would be using `uuid` or MongoDB’s ObjectId for unique identifiers.  

In the route, I also validate input data before creating objects. If required fields are missing, an error is thrown. This ensures data integrity. Then, I created a new `Campaign` and `Product` using the models. The `save` method store documents in database. This method returns a promise, so I used `await` keyword to wait until save operation completes. If product and campaign are saved successfully, a success response is returned. Otherwise, an error response is sent.  

The `/Get_all_products` route handles fetching all products. It uses MongoDB’s aggregation framework to handle pagination. Pagination makes it easier to work with large datasets by showing limited number of products at a time. The route use `$skip` and `$limit` stages to control the number of results. This method is efficient but can be improved by using query parameters for pagination instead of request body. Also, the route should validate page number to prevent errors.  

The `/find_product` route fetches a product by ID. It uses `findOne` method from Mongoose to search database. The `select` method is used to include only necessary fields in the response. This approach reduce the amount of data transferred and make the response faster. If product is not found, a message is returned saying "Product not found". This route can be improved by validating input ID format before searching.  

The `/find_one_delete` route deletes a product by ID using `findOneAndDelete` method. This method find the product and remove it from the database. Before deleting, it checks if ID is provided. If product not found, an error message is sent. Otherwise, a success message is returned.  

The `/update-product` route updates a product by ID using `findOneAndUpdate` method. It create an object called `updatedObj` from request body and run the update operation. Using `exec()` ensures the query is executed. This route can be improved by validating input data before updating. Currently, it will store empty or undefined fields if not handled correctly. It would be better if it first check if product exists before updating.  

Building this project teached me how to use HTTP methods for CRUD operations. POST is used for creating data, GET for reading data, PUT or PATCH for updating, and DELETE for removing data. I also learned importance of input validation and error handling to keep database consistent and reliable. Using MongoDB’s aggregation framework helped me understand how to handle large datasets and perform complex operations.  

The code can be improved in many ways. For example, using middleware for validation, authentication, and logging would make the code cleaner and easier to maintain. Better promise handling using async/await would make the code easier to read and understand. Using environment variables for database connection instead of hardcoded values would make the application more secure. Validation libraries like Joi can be used for more detailed input validation.  

Working on this project was challenging but rewarding. It helped me understand backend development with Node.js, Express, Mongoose, and MongoDB. I gained confidence in setting up backend services, handling requests, and managing data. The project showed me how to write clean and efficient code, and also the importance of error handling.  

This project is a strong foundation for developing more advanced applications. I learned a lot about JavaScript, Node.js, Mongoose, and MongoDB. The experience has made me feel more comfortable with backend development and understand how different technologies work together. I am excited to build more complex projects and learn new skills in the future. Working on this project has been a great learning journey and gave me the confidence to explore more advanced topics in Node.js and backend development.
